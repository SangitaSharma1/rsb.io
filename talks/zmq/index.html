<!DOCTYPE html>
<html>
<head>
  <title>ØMQ - Fast Good and Fast</title>
  <meta charset="utf-8">
  <meta name="description" content="ØMQ - Fast Good and Fast">
  <meta name="author" content="Ryan S. Brown">
  <meta name="generator" content="slidify" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/default.css" media="all" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/phone.css" 
    media="only screen and (max-device-width: 480px)" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/slidify.css" >
  <link rel="stylesheet" href="libraries/highlighters/highlight.js/css/github.css" />
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="libraries/frameworks/io2012/js/slides" 
    src="libraries/frameworks/io2012/js/require-1.0.8.min.js">
  </script>
  
    
</head>
<body style="opacity: 0">
  <slides class="layout-widescreen">
    
    <!-- LOGO SLIDE -->
    <!-- END LOGO SLIDE -->
    

    <!-- TITLE SLIDE -->
    <!-- Should I move this to a Local Layout File? -->
    <slide class="title-slide segue nobackground">
      <hgroup class="auto-fadein">
        <h1>ØMQ - Fast Good and Fast</h1>
        <h2>Did I mention fast?</h2>
        <p>Ryan S. Brown<br/></p>
      </hgroup>
          </slide>

    <!-- SLIDES -->
      <slide class="" id="slide-1" style="background:;">
  <hgroup>
    <h2>Buzzword Bingo</h2>
  </hgroup>
  <article>
    <p>ØMQ (also seen as ZeroMQ, 0MQ, zmq) looks like an embeddable networking library
but acts like a concurrency framework. It gives you sockets that carry atomic
messages across various transports like in-process, inter-process, TCP, and
multicast. You can connect sockets N-to-N with patterns like fanout, pub-sub,
task distribution, and request-reply. It&#39;s fast enough to be the fabric for
clustered products. Its asynchronous I/O model gives you scalable multicore
applications, built as asynchronous message-processing tasks. It has a score of
language APIs and runs on most operating systems. ØMQ is from iMatix and is
LGPLv3 open source.</p>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-2" style="background:;">
  <hgroup>
    <h2>10,000 Foot View</h2>
  </hgroup>
  <article>
    <ul>
<li>Sockets. Exposed to severe 1950&#39;s comic book radioactivity.</li>
<li>Multiple available transports (in-process, TCP, etc)</li>
<li>Flexible topologies</li>
<li>Fast</li>
<li>Async - Runs in background threads</li>
<li>Crossplatform</li>
</ul>

<pre><code class="c">zmq_bind (socket, &quot;tcp://*:5555&quot;);
zmq_bind (socket, &quot;udp://*:9999&quot;);
zmq_bind (socket, &quot;inproc://myipc&quot;);
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-3" style="background:;">
  <hgroup>
    <h2>ØMQ is NOT</h2>
  </hgroup>
  <article>
    <ul>
<li>A messaging server</li>
<li>A replacement for sockets</li>
<li>A message queue (I know, you&#39;re saying &quot;what?&quot;)</li>
<li>A Eureka/Zookeeper replacement</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-4" style="background:;">
  <hgroup>
    <h2>ØMQ IS</h2>
  </hgroup>
  <article>
    <ul>
<li>Awesome</li>
<li>Connectionless</li>
<li>One simple API (distributed topologies with one wierd trick!)</li>
<li>Language-independent wire representation</li>
<li>Stop message floods in a single bound</li>
<li>A tool to build awesome routing topologies</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-5" style="background:;">
  <hgroup>
    <h2>Very Crossplatform</h2>
  </hgroup>
  <article>
    <ul>
<li>40+ language bindings</li>
<li>C, C++, C#, Python, Go, Java, Ruby...</li>
<li>Linux, Windows, OS X, BSD...</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-6" style="background:;">
  <hgroup>
    <h2>What can I send?</h2>
  </hgroup>
  <article>
    <p>Bytes. All the bytes.</p>

<p>Wire format: <code>5hello</code></p>

<p>Big messages are sent in multiple parts</p>

<p>All-or-nothing delivery</p>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-7" style="background:;">
  <hgroup>
    <h2>Simple Patterns</h2>
  </hgroup>
  <article>
    <ul>
<li>REQ and REP</li>
<li>PUB and SUB</li>
<li>PUSH and PULL</li>
<li>PAIR and PAIR</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-8" style="background:;">
  <hgroup>
    <h2>REQ-REP - Request/Reply</h2>
  </hgroup>
  <article>
    <ul>
<li>Remote Procedure Call</li>
<li>Task Distribution</li>
<li>Blocks in lock-step. Only one message can be &quot;open&quot; at a time</li>
</ul>

<p><img src="https://raw.github.com/imatix/zguide/master/images/fig2.png" alt="Request Reply"></p>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-9" style="background:;">
  <hgroup>
    <h2>Hello There</h2>
  </hgroup>
  <article>
    <pre><code class="python">import zmq

context = zmq.Context()

#  Socket to talk to server
print &quot;Connecting to hello world server…&quot;
socket = context.socket(zmq.REQ)
socket.connect (&quot;tcp://localhost:5555&quot;)

#  Do 10 requests, waiting each time for a response
for request in range (10):
    print &quot;Sending request &quot;, request,&quot;…&quot;
    socket.send (&quot;Hello&quot;)

    #  Get the reply.
    message = socket.recv()
    print &quot;Received reply &quot;, request, &quot;[&quot;, message, &quot;]&quot;
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-10" style="background:;">
  <hgroup>
    <h2>REQ-REP - Continued</h2>
  </hgroup>
  <article>
    <ul>
<li>One &quot;open&quot; message per connection</li>
<li>Server can have a lot of clients/open jobs</li>
</ul>

<p><img src="https://raw.github.com/imatix/zguide/master/images/fig47.png" alt="Request Reply"></p>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-11" style="background:;">
  <hgroup>
    <h2>PUB-SUB - Publish/Subscribe</h2>
  </hgroup>
  <article>
    <ul>
<li>N - N</li>
<li>Push data</li>
<li>Publishers can have many Subscribers, and Subscribers can have many Publishers</li>
<li>Publisher can go offline and Subscribers await his return (partition tolerance you say?)</li>
<li>Subscribers can&#39;t tell the publisher anything &quot;hey, I went offline, can I have the last X messages?&quot;</li>
<li>Word of the day is still &quot;idempotency&quot;</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-12" style="background:;">
  <hgroup>
    <h2>PUSH-PULL</h2>
  </hgroup>
  <article>
    <ul>
<li>More queue-like</li>
<li>Great for fan in or fan out messaging</li>
<li>One-way. If a client dies it&#39;s up to you to notice the job didn&#39;t get to the end of the pipeline</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-13" style="background:;">
  <hgroup>
    <h2>PUSH-PULL - Continued</h2>
  </hgroup>
  <article>
    <p><img src="https://raw.github.com/imatix/zguide/master/images/fig5.png" alt="Fan In Fan Out"></p>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-14" style="background:;">
  <hgroup>
    <h2>PAIR-PAIR</h2>
  </hgroup>
  <article>
    <ul>
<li>Closely related to a normal socket</li>
<li>Write arbitrarily</li>
<li>Least interesting of the patterns</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-15" style="background:;">
  <hgroup>
    <h2>Advanced Patterns</h2>
  </hgroup>
  <article>
    <ul>
<li>REQ and ROUTER</li>
<li>DEALER and REP</li>
<li>DEALER and ROUTER</li>
<li>DEALER and DEALER</li>
<li>ROUTER and ROUTER</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-16" style="background:;">
  <hgroup>
    <h2>Router and Dealer</h2>
  </hgroup>
  <article>
    <ul>
<li>1-N</li>
<li>Ships messages from front to back, no blocking</li>
<li>Messages gain a connection ID as they go through so the REP can come back</li>
<li>Only the Router and Dealer know about those IDs</li>
</ul>

<p><img src="https://raw.github.com/imatix/zguide/master/images/fig16.png" alt="Router and Dealer"></p>

  </article>
  <!-- Presenter Notes -->
</slide>

      <slide class="" id="slide-17" style="background:;">
  <hgroup>
    <h2>References</h2>
  </hgroup>
  <article>
    <ul>
<li><a href="http://zguide.zeromq.org/page:all">The zmq Guide</a></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

    <slide class="backdrop"></slide>
  </slides>

  <!--[if IE]>
    <script 
      src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js">  
    </script>
    <script>CFInstall.check({mode: 'overlay'});</script>
  <![endif]-->
</body>
<!-- Grab CDN jQuery, fall back to local if offline -->
<script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.min.js"></script>
<script>window.jQuery || document.write('<script src="libraries/widgets/quiz/js/jquery-1.7.min.js"><\/script>')</script>
<!-- Load Javascripts for Widgets -->
<!-- LOAD HIGHLIGHTER JS FILES -->
<script src="libraries/highlighters/highlight.js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!-- DONE LOADING HIGHLIGHTER JS FILES -->
</html>